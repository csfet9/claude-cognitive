/**
 * CLI sync command - regenerate memory.md from Hindsight.
 * @module cli/commands/sync
 */

import type { CAC } from "cac";
import { Mind } from "../../mind.js";
import type { Memory } from "../../types.js";
import { CLIError, ExitCode, info, output } from "../utils/index.js";

interface SyncOptions {
  project?: string;
  dryRun?: boolean;
  json?: boolean;
  quiet?: boolean;
}

interface SyncResult {
  timestamp: string;
  memoriesProcessed: number;
  sections: {
    techStack: number;
    patterns: number;
    observations: number;
    recentActivity: number;
  };
  path: string;
  dryRun: boolean;
}

/**
 * Deduplicate memories by ID.
 */
function deduplicateMemories(memories: Memory[]): Memory[] {
  const seen = new Set<string>();
  return memories.filter((m) => {
    if (seen.has(m.id)) {
      return false;
    }
    seen.add(m.id);
    return true;
  });
}

/**
 * Group memories by fact type.
 */
function groupByType(memories: Memory[]): Record<string, Memory[]> {
  const groups: Record<string, Memory[]> = {
    world: [],
    experience: [],
    opinion: [],
    observation: [],
  };

  for (const memory of memories) {
    const type = memory.factType || "world";
    if (groups[type]) {
      groups[type].push(memory);
    }
  }

  return groups;
}

/**
 * Extract tech stack facts from world memories.
 */
function extractTechStack(worldMemories: Memory[]): string[] {
  const techKeywords = [
    "uses",
    "built with",
    "framework",
    "library",
    "database",
    "typescript",
    "javascript",
    "react",
    "node",
    "python",
    "rust",
    "go",
    "api",
    "sdk",
  ];

  return worldMemories
    .filter((m) => {
      const text = m.text.toLowerCase();
      return techKeywords.some((kw) => text.includes(kw));
    })
    .map((m) => `- ${m.text}`)
    .slice(0, 15); // Limit to top 15
}

/**
 * Extract patterns from opinions.
 */
function extractPatterns(opinions: Memory[]): string[] {
  return opinions
    .filter((m) => (m.confidence ?? 0) >= 0.5)
    .sort((a, b) => (b.confidence ?? 0) - (a.confidence ?? 0))
    .map((m) => {
      const confidence = ((m.confidence ?? 0) * 100).toFixed(0);
      return `- ${m.text} (${confidence}% confidence)`;
    })
    .slice(0, 10); // Top 10 patterns
}

/**
 * Extract high-confidence observations.
 */
function extractObservations(opinions: Memory[]): string[] {
  return opinions
    .filter((m) => (m.confidence ?? 0) >= 0.8)
    .sort((a, b) => (b.confidence ?? 0) - (a.confidence ?? 0))
    .map((m) => {
      const date = new Date(m.createdAt).toISOString().split("T")[0];
      const confidence = ((m.confidence ?? 0) * 100).toFixed(0);
      return `- ${m.text} (${date}, ${confidence}%)`;
    })
    .slice(0, 10);
}

/**
 * Extract recent experiences.
 */
function extractRecentActivity(experiences: Memory[]): string[] {
  return experiences
    .sort(
      (a, b) =>
        new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime(),
    )
    .map((m) => {
      const date = new Date(m.createdAt).toISOString().split("T")[0];
      // Truncate long experiences
      const text =
        m.text.length > 150 ? m.text.substring(0, 147) + "..." : m.text;
      return `- ${date}: ${text}`;
    })
    .slice(0, 10);
}

/**
 * Generate the memory.md content.
 */
function generateMemoryContent(
  memories: Memory[],
  timestamp: string,
): { content: string; sections: SyncResult["sections"] } {
  const groups = groupByType(memories);

  const techStack = extractTechStack(groups.world ?? []);
  const patterns = extractPatterns(groups.opinion ?? []);
  const observations = extractObservations(groups.opinion ?? []);
  const recentActivity = extractRecentActivity(groups.experience ?? []);

  const sections: SyncResult["sections"] = {
    techStack: techStack.length,
    patterns: patterns.length,
    observations: observations.length,
    recentActivity: recentActivity.length,
  };

  const parts: string[] = [];

  // Header with timestamp
  parts.push(`<!-- Last synced: ${timestamp} -->`);
  parts.push(`<!-- Auto-generated by claude-cognitive sync -->`);
  parts.push("");

  // Tech Stack section
  parts.push("## Tech Stack");
  parts.push("");
  if (techStack.length > 0) {
    parts.push(...techStack);
  } else {
    parts.push("<!-- No tech stack information found -->");
  }
  parts.push("");

  // Key Patterns section
  parts.push("## Key Patterns");
  parts.push("");
  if (patterns.length > 0) {
    parts.push(...patterns);
  } else {
    parts.push("<!-- No patterns identified yet -->");
  }
  parts.push("");

  // Observations section (high-confidence insights)
  parts.push("## Observations");
  parts.push("");
  if (observations.length > 0) {
    parts.push(...observations);
  } else {
    parts.push("<!-- No high-confidence observations yet -->");
  }
  parts.push("");

  // Recent Activity section
  parts.push("## Recent Activity");
  parts.push("");
  if (recentActivity.length > 0) {
    parts.push(...recentActivity);
  } else {
    parts.push("<!-- No recent activity recorded -->");
  }
  parts.push("");

  return { content: parts.join("\n"), sections };
}

/**
 * Format sync result for human-readable output.
 */
function formatSyncResult(result: SyncResult): string {
  const lines: string[] = [];

  if (result.dryRun) {
    lines.push("=== DRY RUN (no changes written) ===");
    lines.push("");
  }

  lines.push(`Synced memory.md from Hindsight`);
  lines.push(`  Timestamp: ${result.timestamp}`);
  lines.push(`  Memories processed: ${result.memoriesProcessed}`);
  lines.push(`  Path: ${result.path}`);
  lines.push("");
  lines.push("Sections generated:");
  lines.push(`  Tech Stack: ${result.sections.techStack} items`);
  lines.push(`  Key Patterns: ${result.sections.patterns} items`);
  lines.push(`  Observations: ${result.sections.observations} items`);
  lines.push(`  Recent Activity: ${result.sections.recentActivity} items`);

  return lines.join("\n");
}

/**
 * Register the sync command.
 */
export function registerSyncCommand(cli: CAC): void {
  cli
    .command("sync", "Regenerate memory.md from Hindsight memories")
    .option(
      "--project <path>",
      "Project directory (default: current directory)",
    )
    .option("--dry-run", "Preview changes without writing")
    .option("--json", "Output as JSON")
    .option("--quiet", "Suppress output")
    .action(async (options: SyncOptions) => {
      const projectPath = options.project ?? process.cwd();

      const mind = new Mind({ projectPath });
      await mind.init();

      if (mind.isDegraded) {
        throw new CLIError(
          "Cannot sync: Hindsight is unavailable.",
          ExitCode.CONNECTION_ERROR,
          "Make sure Hindsight is running and accessible.",
        );
      }

      info("Syncing memory.md from Hindsight...", options);

      // Query all memory types
      const [worldMemories, experienceMemories, opinionMemories] =
        await Promise.all([
          mind.recall("project technology stack architecture", {
            factType: "world",
            budget: "high",
          }),
          mind.recall("recent work changes fixes", {
            factType: "experience",
            budget: "mid",
          }),
          mind.recall("patterns insights observations beliefs", {
            factType: "opinion",
            budget: "high",
          }),
        ]);

      // Deduplicate memories (recall queries may overlap)
      const allMemories = deduplicateMemories([
        ...worldMemories,
        ...experienceMemories,
        ...opinionMemories,
      ]);

      const timestamp = new Date().toISOString();
      const { content, sections } = generateMemoryContent(
        allMemories,
        timestamp,
      );

      const semanticMemory = mind.getSemanticMemory();
      if (!semanticMemory) {
        throw new CLIError(
          "Semantic memory not initialized.",
          ExitCode.GENERAL_ERROR,
        );
      }

      const result: SyncResult = {
        timestamp,
        memoriesProcessed: allMemories.length,
        sections,
        path: semanticMemory.getFilePath(),
        dryRun: options.dryRun ?? false,
      };

      // Write unless dry run
      if (!options.dryRun) {
        const { writeFile, mkdir } = await import("node:fs/promises");
        const { dirname } = await import("node:path");

        // Ensure directory exists
        await mkdir(dirname(semanticMemory.getFilePath()), { recursive: true });

        // Write the file
        await writeFile(semanticMemory.getFilePath(), content, "utf-8");
      } else if (!options.json && !options.quiet) {
        // In dry-run mode, show the content that would be written
        console.error("\n--- Generated content ---\n");
        console.error(content);
        console.error("--- End generated content ---\n");
      }

      output(result, formatSyncResult, options);
    });
}
